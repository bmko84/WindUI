

-----------------------------------------------
-- Services & Player (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏π‡πÄ‡∏á‡∏¥‡∏ô / hop)
------------------------------------------------
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local player = LocalPlayer
local placeId = game.PlaceId
local visitedServers = {}
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local Net = require(game.ReplicatedStorage.Modules.Core.Net)

local ReplicatedStorage = 
game:GetService("ReplicatedStorage") 

local kickF = LocalPlayer.Kick

local Players, LocalPlayer, ReplicatedStorage =
game:GetService("Players"), game.Players.LocalPlayer,
game:GetService("ReplicatedStorage")

------------------------------------------------
-- Load WindUI
------------------------------------------------
local WindUI = loadstring(game:HttpGet(
    "https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"
))()

------------------------------------------------
-- Create Window
------------------------------------------------
local Window = WindUI:CreateWindow({
    Title = "bmegono1",
    Icon = "zap",
    Author = "bmegono1",
    Folder = "MySuperHub",

    Size = UDim2.fromOffset(580, 460),
    MinSize = Vector2.new(560, 350),
    MaxSize = Vector2.new(850, 560),
    Transparent = true,
    Theme = "Dark",
    Resizable = true,
    SideBarWidth = 200,
    BackgroundImageTransparency = 0.42,
    HideSearchBar = true,
    ScrollBarEnabled = false,

    User = {
        Enabled = true,
        Anonymous = false,
        Name = LocalPlayer.Name,
        Image = "rbxthumb://type=AvatarHeadShot&id=" .. LocalPlayer.UserId,
        Callback = function() end,
    },
})

Window:Tag({
    Title = "Paid",
    Icon = "lock-open",
    Color = Color3.fromHex("#FF0000")
})

------------------------------------------------
-- Tabs
------------------------------------------------
local CombatTab = Window:Tab({ Title = "Combat", Icon = "sword" })
local EspTab    = Window:Tab({ Title = "ESP",    Icon = "eye" })
local PlayerTab = Window:Tab({ Title = "Player", Icon = "user" })
local VehicleTab = Window:Tab({Title = "Vehicle",Icon = "car" })
local GunmodeTab = Window:Tab({ Title = "Gunmode", Icon = "crosshair" })
local MiscTab   = Window:Tab({ Title = "Misc",   Icon = "cog" })
local ServerTab = Window:Tab({Title = "Server",Icon = "server"})
local ConfigTab = Window:Tab({Title = "Config", Icon = "save"})

------------------------------------------------
-- Disable default Open Button
------------------------------------------------
Window:EditOpenButton({ Enabled = false })

------------------------------------------------
-- Image Toggle Button (‡∏ö‡∏ô-‡∏Å‡∏•‡∏≤‡∏á)
------------------------------------------------
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "WindUI_ImageToggle"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = CoreGui

local ToggleBtn = Instance.new("ImageButton")
ToggleBtn.Parent = ScreenGui
ToggleBtn.Size = UDim2.new(0, 50, 0, 50)
ToggleBtn.Position = UDim2.new(0.5, -25, 0, 20)
ToggleBtn.BackgroundTransparency = 1
ToggleBtn.Image = "rbxassetid://129529601820099"
ToggleBtn.Active = true
ToggleBtn.Draggable = true

local function toggleUI()
    Window:Toggle()
end

ToggleBtn.MouseButton1Click:Connect(function()
    TweenService:Create(
        ToggleBtn,
        TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        { Size = UDim2.new(0, 56, 0, 56) }
    ):Play()
    task.wait(0.12)
    TweenService:Create(
        ToggleBtn,
        TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        { Size = UDim2.new(0, 50, 0, 50) }
    ):Play()
    toggleUI()
end)

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.T then
        toggleUI()
    end
end)
local BankBalance = CombatTab:Button({Title = "üè¶ Bank Balance", Desc = "N/A"})
local HandBalance = CombatTab:Button({Title = "üí∏ Hand Balance", Desc = "N/A"})

local function HandMoney()
    local success, value = pcall(function()
        local topRight = PlayerGui:FindFirstChild("TopRightHud")
        if topRight then
            local holder = topRight:FindFirstChild("Holder")
            if holder and holder:FindFirstChild("Frame") and holder.Frame:FindFirstChild("MoneyTextLabel") then
                return tonumber(holder.Frame.MoneyTextLabel.Text:match("%$(%d+)"))
            end
        end
        return 0
    end)
    return success and value or 0
end

local function ATMMoney()
    for _, v in ipairs(PlayerGui:GetDescendants()) do
        if v:IsA("TextLabel") and string.find(v.Text, "Bank Balance") then
            local success, value = pcall(function()
                return tonumber(v.Text:match("%$(%d+)"))
            end)
            if success then return value end
        end
    end
    return 0
end

task.spawn(function()
    while task.wait(0.2) do
        BankBalance:SetDesc('<b><font color="#00FF00">$' .. (ATMMoney() or 0) .. "</font></b>")
        HandBalance:SetDesc('<b><font color="#00f2ff">$' .. (HandMoney() or 0) .. "</font></b>")
    end
end)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

local SilentAimEnabled = false
local EnableWallBang = false

CombatTab:Toggle({
    Title = "Enable Silent Aim",
    Default = false,
    Callback = function(v)
        SilentAimEnabled = v
    end
})

CombatTab:Toggle({
    Title = "Enable Wall Bang",
    Default = false,
    Callback = function(v)
        EnableWallBang = v
    end
})

local FOVCircle = Drawing.new("Circle")
FOVCircle.Radius = 150
FOVCircle.Thickness = 0.5
FOVCircle.Filled = false
FOVCircle.Color = Color3.fromRGB(255,0,0)
FOVCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
FOVCircle.Visible = false
local showFov = false

CombatTab:Toggle({
    Title = "Enable FOV Circle",
    Default = false,
    Callback = function(state)
        showFov = state
        FOVCircle.Visible = showFov
    end
})

CombatTab:Slider({
    Title = "FOV Radius",
    Step = 1,
    Value = {Min = 50, Max = 500, Default = FOVCircle.Radius},
    Callback = function(value)
        FOVCircle.Radius = tonumber(value)
    end
})

local CurrentTarget
local BodyPartOptions = {"Head", "HumanoidRootPart"}
local SelectedBodyPart = "Head"

CombatTab:Dropdown({
    Flag = "TargetBodyPart",
    Title = "Lock Body Part",
    Values = BodyPartOptions,
    Value = "Head",
    Callback = function(option)
        SelectedBodyPart = option
    end
})

local IgnoredPlayers = {}

local function GetPlayerDropdownOptions()
    local options = {}
    for _, player in pairs(Players:GetPlayers()) do
        table.insert(options, player.Name)
    end
    return options
end

local ignoreDropdown
ignoreDropdown = CombatTab:Dropdown({
    Flag = "IgnorePlayers",
    Title = "Ignore Players",
    Values = GetPlayerDropdownOptions(),
    Value = {},
    Multi = true,
    Callback = function(selectedOptions)
        IgnoredPlayers = {}
        for _, v in ipairs(selectedOptions) do
            table.insert(IgnoredPlayers, v)
        end
    end
})

CombatTab:Button({
    Title = "Reset Ignored Players",
    Callback = function()
        IgnoredPlayers = {}
        if ignoreDropdown then
            if ignoreDropdown.Reset then
                ignoreDropdown:Reset()
            end
            if ignoreDropdown.SetValues then
                ignoreDropdown:SetValues(GetPlayerDropdownOptions())
            end
        end
    end
})

Players.PlayerAdded:Connect(function(player)
    if ignoreDropdown and ignoreDropdown.SetValues then
        ignoreDropdown:SetValues(GetPlayerDropdownOptions())
    end
end)

Players.PlayerRemoving:Connect(function(player)
    for i=#IgnoredPlayers,1,-1 do
        if IgnoredPlayers[i] == player.Name then
            table.remove(IgnoredPlayers,i)
        end
    end
    if ignoreDropdown and ignoreDropdown.SetValues then
        ignoreDropdown:SetValues(GetPlayerDropdownOptions())
    end
end)

local DebugGuns = {
    ["P226"]=true, ["MP5"]=true, ["M24"]=true, ["Draco"]=true, ["Glock"]=true,
    ["Sawnoff"]=true, ["Uzi"]=true, ["G3"]=true, ["C9"]=true, ["Hunting Rifle"]=true,
    ["Anaconda"]=true, ["AK47"]=true, ["Remington"]=true, ["Double Barrel"]=true
}

local function IsHoldingAllowedGun(args)
    local ok, weapon = pcall(function() return args[3] end)
    if not ok then return false end
    if typeof(weapon) == "Instance" and DebugGuns[weapon.Name] then return true end
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if (child:IsA("Tool") or child:IsA("Model")) and DebugGuns[child.Name] then return true end
    end
    return false
end

local tracerLine = Drawing.new("Line")
tracerLine.Color = Color3.fromRGB(255,0,0)
tracerLine.Thickness = 2
tracerLine.Visible = false

local PREDICTION_BASE = 0.15
local WALLBANG_FACTOR_ROOT = 1.0
local WALLBANG_FACTOR_SEAT = 1.2
local HEAD_VEL_FACTOR = 0.1
local ROOT_VEL_FACTOR = 0.12

local function PredictPosition(part, enableWallBang)
    local root = part.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return part.Position end
    local velocityFactor = (part.Name == "Head") and HEAD_VEL_FACTOR or ROOT_VEL_FACTOR
    local baseVelocity = root.Velocity
    if part:IsA("BasePart") then
        baseVelocity = baseVelocity + (part.Velocity * velocityFactor)
    end
    local prediction = part.Position + (baseVelocity * PREDICTION_BASE)
    if enableWallBang then
        local seat = root:FindFirstChildWhichIsA("WeldConstraint") or root:FindFirstChildWhichIsA("Weld")
        if seat and seat.Part0 and seat.Part0.Velocity then
            local rootVel = root.Velocity * WALLBANG_FACTOR_ROOT
            local seatVel = seat.Part0.Velocity * WALLBANG_FACTOR_SEAT
            prediction = part.Position + ((rootVel + seatVel) * PREDICTION_BASE)
        end
    end
    return prediction
end

local function SpawnDebugBullet(startPos, targetPos)
    local dist = (targetPos - startPos).Magnitude
    local beam = Instance.new("Part")
    beam.Anchored = true
    beam.CanCollide = false
    beam.Material = Enum.Material.Neon
    beam.Size = Vector3.new(0.1,0.1,dist)
    beam.CFrame = CFrame.new(startPos, targetPos) * CFrame.new(0,0,-dist/2)
    local hue = (tick()*0.5)%1
    beam.Color = Color3.fromHSV(hue, 1, 1)
    beam.Parent = Workspace
    Debris:AddItem(beam, 0.5)
end

local function GetTargetPart(character)
    if not character then return nil end
    return character:FindFirstChild(SelectedBodyPart) or character:FindFirstChild("HumanoidRootPart")
end

local function GetClosestTarget()
    local closest
    local shortest = math.huge
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and not table.find(IgnoredPlayers, player.Name) then
            local part = GetTargetPart(player.Character)
            if part then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                    if showFov then
                        if dist < FOVCircle.Radius and dist < shortest then
                            shortest = dist
                            closest = player
                        end
                    else
                        if dist < shortest then
                            shortest = dist
                            closest = player
                        end
                    end
                end
            end
        end
    end
    return closest
end

local function IsShooting(args)
    for i, v in pairs(args) do
        if typeof(v) == "string" and v:lower():find("shoot") then
            return true
        elseif typeof(v) == "table" then
            for _, t in pairs(v) do
                if typeof(t) == "table" and t.Instance and t.Position then
                    return true
                end
            end
        end
    end
    return false
end

local send = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local oldFire
oldFire = hookfunction(send.FireServer, function(self, ...)
    local args = {...}
    if SilentAimEnabled and IsHoldingAllowedGun(args) then
        if IsShooting(args) then
            CurrentTarget = GetClosestTarget()
            if CurrentTarget and CurrentTarget.Character then
                local targetPart = GetTargetPart(CurrentTarget.Character)
                local myHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
                if targetPart and myHead then
                    local predicted = PredictPosition(targetPart, EnableWallBang)
                    if EnableWallBang then
                        if args[5] and args[5][1] and args[5][1][1] then
                            args[5][1][1].Instance = targetPart
                            args[5][1][1].Position = predicted
                        end
                        args[4] = CFrame.new(math.huge, math.huge, math.huge)
                    else
                        if args[5] and args[5][1] and args[5][1][1] then
                            args[5][1][1].Instance = targetPart
                            args[5][1][1].Position = predicted
                        end
                    end
                    SpawnDebugBullet(myHead.Position, predicted)
                end
            end
        end
    end
    return oldFire(self, unpack(args))
end)

RunService.RenderStepped:Connect(function()
    local closestTarget = SilentAimEnabled and GetClosestTarget() or nil
    local viewportCenter = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    FOVCircle.Visible = showFov
    if showFov then
        FOVCircle.Position = viewportCenter
    end
    if SilentAimEnabled and closestTarget and closestTarget.Character then
        local humanoid = closestTarget.Character:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.Health > 0 then
            local myHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
            local aimPart = GetTargetPart(closestTarget.Character)
            if myHead and aimPart then
                local screenStart, onScreenStart = Camera:WorldToViewportPoint(myHead.Position)
                local screenEnd, onScreenEnd = Camera:WorldToViewportPoint(aimPart.Position)
                if onScreenStart and onScreenEnd then
                    tracerLine.From = Vector2.new(screenStart.X, screenStart.Y)
                    tracerLine.To = Vector2.new(screenEnd.X, screenEnd.Y)
                    tracerLine.Thickness = 2
                    tracerLine.Color = Color3.fromRGB(255,0,0)
                    tracerLine.Visible = true
                else
                    tracerLine.Visible = false
                end
            else
                tracerLine.Visible = false
            end
        else
            tracerLine.Visible = false
        end
    else
        tracerLine.Visible = false
    end
end)
getgenv().HitAuraEnabled = false
local autoLoop = nil

local function getActiveTool()
    local char = LocalPlayer.Character
    if not char then return nil end
    for _, obj in pairs(char:GetChildren()) do
        if obj:IsA("Tool") then return obj end
    end
    return nil
end

local function getPlayersInRange(radius)
    local inRange = {}
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return inRange end
    local pos = char.HumanoidRootPart.Position
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart")
            and p.Character:FindFirstChild("Humanoid") and p.Character.Humanoid.Health > 0 then
            local dist = (p.Character.HumanoidRootPart.Position - pos).Magnitude
            if dist <= radius then
                table.insert(inRange, p)
            end
        end
    end
    return inRange
end

local function AttackNearby()
    local tool = getActiveTool()
    if not tool then return end
    local targets = getPlayersInRange(12)
    for _, target in ipairs(targets) do
        local hrp = LocalPlayer.Character.HumanoidRootPart
        local targetHRP = target.Character.HumanoidRootPart
        if hrp and targetHRP then
            local lookAtCFrame = CFrame.lookAt(hrp.Position, targetHRP.Position)
            local CounterTable
            pcall(function()
                for _, Obj in ipairs(getgc(true)) do
                    if typeof(Obj) == "table" and rawget(Obj, "event") and rawget(Obj, "func") then
                        CounterTable = Obj
                        break
                    end
                end
            end)
            local SendRemote
            pcall(function()
                local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
                SendRemote = Remotes:WaitForChild("Send", 5)
            end)
            if CounterTable and SendRemote then
                CounterTable.event = (CounterTable.event or 0) + 1
                pcall(function()
                    SendRemote:FireServer(CounterTable.event, "melee_attack", tool, {target}, lookAtCFrame, 0.75)
                end)
            end
        end
    end
end

local function StartHitAura()
    if autoLoop then return end
    autoLoop = task.spawn(function()
        while getgenv().HitAuraEnabled do
            pcall(AttackNearby)
            task.wait(0.3)
        end
    end)
end

local function StopHitAura()
    getgenv().HitAuraEnabled = false
    if autoLoop then
        task.cancel(autoLoop)
        autoLoop = nil
    end
end

function ToggleHitAura(state)
    if state then
        getgenv().HitAuraEnabled = true
        StartHitAura()
        print("‚úÖ Hit Aura: ON")
    else
        StopHitAura()
        print("‚ùå Hit Aura: OFF")
    end
end

CombatTab:Toggle({
    Title = "Hit Aura",
    Default = false,
    Callback = function(state)
        ToggleHitAura(state)
    end
})

